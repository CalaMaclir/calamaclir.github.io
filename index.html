<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>EasyCrypt</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1, h2, h3 { margin-bottom: 10px; }
    /* ファイルドラッグ領域 */
    #fileDropArea {
      border: 2px dashed #888;
      padding: 20px;
      text-align: center;
      margin-bottom: 10px;
    }
    .key-section { border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; }
    button { margin: 5px; }
    ul { list-style: none; padding-left: 0; }
    li { margin-bottom: 5px; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    textarea { width: 100%; }
    section { margin-bottom: 30px; }
  </style>
</head>
<body>
  <h1>EasyCrypt</h1>
　鍵はブラウザ内のIndexedDB内に保存されます。ブラウザを閉じても保持されます。</br>
　鍵生成、暗号化、復号すべての処理はブラウザ内でローカルに処理され、外部との通信は行われません。</br>

  <!-- ファイル暗号化／復号セクション -->
  <section id="fileSection">
    <h2>暗号化／復号の対象ファイル</h2>
    <div id="fileDropArea">ここにファイルをドロップ</div>
    <ul id="fileList"></ul>
    <!-- 復号ボタンのみ表示（暗号化は下記公開鍵エリアへ移動） -->
    <div class="key-section">
      <h2>復号</h2>
      秘密鍵は自動選択されます
      <button id="decryptBtn">復号</button>
    </div>
  </section>

  <!-- 公開鍵選択エリア（暗号化ボタンを含む） -->
  <section id="keyImport">
    <div class="key-section">
      <h2>暗号化</h2>
      暗号化で使用する公開鍵のファイルを読ませてください
      <h3>公開鍵選択 (.pubkey XML)</h3>
      <input type="file" id="pubKeyInput" accept=".pubkey" multiple>
      <!-- 暗号化ボタンはここに配置 -->
      <button id="encryptBtn">暗号化</button>
      <ul id="pubKeyList"></ul>
    </div>
  </section>

  <!-- 鍵管理セクション -->
  <section id="keyManagement">
    <div class="key-section">
    <h2>鍵管理</h2>
    <div>
      <label for="keyNameInput">鍵名 (英数字、_, -, @, . のみ): </label>
      <input type="text" id="keyNameInput" placeholder="例: MyKey01">
      <button id="generateKeyButton">鍵生成</button>
    </div>
    <div>
      <h3>鍵一覧</h3>
      <table id="keyTable">
        <thead>
          <tr>
            <th>鍵名</th>
            <th>操作</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div id="exportArea"></div>
    </div>
  </section>

  <script>
    // ── グローバル変数 ──
    let db;
    // キーペア（自前生成したもの）の管理用オブジェクト（鍵名をキー）
    const keyStore = {};
    // 暗号処理用にインポート済みの鍵リスト（ファイルインポートまたはDB復元）
    const importedPublicKeys = [];   // { name, modulus, cryptoKey }
    const importedPrivateKeys = [];  // { name, modulus, cryptoKey }
    // 処理対象ファイルリスト
    const filesToProcess = [];

    // ── IndexedDB 初期化と操作 ──
    function initDB() {
      const request = indexedDB.open("EasyCryptDB", 1);
      request.onupgradeneeded = function(e) {
        db = e.target.result;
        if (!db.objectStoreNames.contains("keys")) {
          db.createObjectStore("keys", { keyPath: "name" });
        }
      };
      request.onsuccess = function(e) {
        db = e.target.result;
        loadKeysFromDB();
      };
      request.onerror = function(e) {
        console.error("IndexedDB error", e);
      };
    }

    function storeKeyRecord(record) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction("keys", "readwrite");
        const store = transaction.objectStore("keys");
        const req = store.put(record);
        req.onsuccess = () => resolve();
        req.onerror = (e) => reject(e);
      });
    }

    function deleteKeyRecord(name) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction("keys", "readwrite");
        const store = transaction.objectStore("keys");
        const req = store.delete(name);
        req.onsuccess = () => resolve();
        req.onerror = (e) => reject(e);
      });
    }

    function getKeyRecord(name) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction("keys", "readonly");
        const store = transaction.objectStore("keys");
        const req = store.get(name);
        req.onsuccess = () => resolve(req.result);
        req.onerror = (e) => reject(e);
      });
    }

    async function storeKeyPair(name, publicJwk, privateJwk) {
      let record = await getKeyRecord(name);
      if (!record) {
        record = { name: name, publicKeyJwk: publicJwk, privateKeyJwk: privateJwk };
      } else {
        record.publicKeyJwk = publicJwk;
        record.privateKeyJwk = privateJwk;
      }
      await storeKeyRecord(record);
    }

    async function storePartialKey(name, jwk, type) {
      let record = await getKeyRecord(name);
      if (!record) {
        record = { name: name, publicKeyJwk: null, privateKeyJwk: null };
      }
      if (type === "public") {
        record.publicKeyJwk = jwk;
      } else if (type === "private") {
        record.privateKeyJwk = jwk;
      }
      await storeKeyRecord(record);
    }

    function loadKeysFromDB() {
      const transaction = db.transaction("keys", "readonly");
      const store = transaction.objectStore("keys");
      const req = store.getAll();
      req.onsuccess = async function() {
        const records = req.result;
        for (const record of records) {
          if (record.publicKeyJwk) {
            const pubKey = await crypto.subtle.importKey(
              "jwk", record.publicKeyJwk,
              { name: "RSA-OAEP", hash: "SHA-1" },
              true, ["encrypt"]
            );
            const modulus = base64UrlToBase64(record.publicKeyJwk.n);
            importedPublicKeys.push({ name: record.name, modulus: modulus, cryptoKey: pubKey });
          }
          if (record.privateKeyJwk) {
            const privKey = await crypto.subtle.importKey(
              "jwk", record.privateKeyJwk,
              { name: "RSA-OAEP", hash: "SHA-1" },
              true, ["decrypt"]
            );
            const modulus = record.publicKeyJwk ? base64UrlToBase64(record.publicKeyJwk.n) : "";
            importedPrivateKeys.push({ name: record.name, modulus: modulus, cryptoKey: privKey });
          }
          if (record.publicKeyJwk && record.privateKeyJwk) {
            const pubKey = await crypto.subtle.importKey(
              "jwk", record.publicKeyJwk,
              { name: "RSA-OAEP", hash: "SHA-1" },
              true, ["encrypt"]
            );
            const privKey = await crypto.subtle.importKey(
              "jwk", record.privateKeyJwk,
              { name: "RSA-OAEP", hash: "SHA-1" },
              true, ["decrypt"]
            );
            keyStore[record.name] = { publicKey: pubKey, privateKey: privKey };
          }
        }
        refreshKeyList();
      }
    }

    // ── ユーティリティ関数 ──
    function concatUint8Arrays(arrays) {
      let total = arrays.reduce((sum, arr) => sum + arr.length, 0);
      let result = new Uint8Array(total);
      let offset = 0;
      arrays.forEach(arr => { result.set(arr, offset); offset += arr.length; });
      return result;
    }
    function writeInt32LE(val) {
      const buf = new ArrayBuffer(4);
      new DataView(buf).setInt32(0, val, true);
      return new Uint8Array(buf);
    }
    function readInt32LE(view, offset) {
      return view.getInt32(offset, true);
    }
    // 標準 base64 → base64url（パディング除去）
    function base64ToBase64Url(b64) {
      return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }
    // base64url → 標準 base64（パディング追加）
    function base64UrlToBase64(url) {
      let b64 = url.replace(/-/g, '+').replace(/_/g, '/');
      while (b64.length % 4 !== 0) { b64 += '='; }
      return b64;
    }
    // XML から指定タグの内容取得
    function getXmlTagContent(xmlDoc, tagName) {
      const el = xmlDoc.getElementsByTagName(tagName)[0];
      return el ? el.textContent.trim() : null;
    }

    // ── XML 形式の公開鍵インポート ──
    async function importPublicKeyFromXml(xmlString, fileName) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "application/xml");
      const modulus = getXmlTagContent(xmlDoc, "Modulus");
      const exponent = getXmlTagContent(xmlDoc, "Exponent");
      if (!modulus || !exponent) {
        throw new Error("公開鍵XMLに Modulus または Exponent が見つかりません");
      }
      const n = base64ToBase64Url(modulus);
      const e = base64ToBase64Url(exponent);
      const jwk = { kty: "RSA", n: n, e: e, ext: true };
      const cryptoKey = await crypto.subtle.importKey(
        "jwk", jwk,
        { name: "RSA-OAEP", hash: "SHA-1" },
        true, ["encrypt"]
      );
      return { name: fileName, modulus: modulus, cryptoKey: cryptoKey };
    }

    // ── ファイルドラッグ＆ドロップ処理 ──
    const fileDropArea = document.getElementById('fileDropArea');
    const fileListElem = document.getElementById('fileList');
    fileDropArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileDropArea.style.borderColor = "#000";
    });
    fileDropArea.addEventListener('dragleave', (e) => {
      e.preventDefault();
      fileDropArea.style.borderColor = "#888";
    });
    fileDropArea.addEventListener('drop', (e) => {
      e.preventDefault();
      fileDropArea.style.borderColor = "#888";
      const files = e.dataTransfer.files;
      for (let file of files) {
        filesToProcess.push(file);
        const li = document.createElement('li');
        li.textContent = file.name;
        fileListElem.appendChild(li);
      }
    });

    // ── 公開鍵ファイル入力（インポート＆DB保存） ──
    const pubKeyListElem = document.getElementById('pubKeyList');
    document.getElementById('pubKeyInput').addEventListener('change', async (e) => {
      const files = e.target.files;
      for (let file of files) {
        const text = await file.text();
        try {
          const pubKey = await importPublicKeyFromXml(text, file.name);
          importedPublicKeys.push(pubKey);
          const li = document.createElement('li');
          li.textContent = pubKey.name;
          pubKeyListElem.appendChild(li);
          // DB へ保存（公開鍵のみ）
          const jwk = await crypto.subtle.exportKey("jwk", pubKey.cryptoKey);
          await storePartialKey(pubKey.name, jwk, "public");
        } catch(err) {
          alert("公開鍵 " + file.name + " のインポートエラー: " + err.message);
        }
      }
      e.target.value = "";
    });

    // ── ファイル暗号化処理 ──
    async function encryptFile(file) {
      // AES-CBC 用鍵と IV 生成
      const aesKey = await crypto.subtle.generateKey({ name: "AES-CBC", length: 256 }, true, ["encrypt", "decrypt"]);
      const aesKeyRaw = new Uint8Array(await crypto.subtle.exportKey("raw", aesKey));
      const iv = window.crypto.getRandomValues(new Uint8Array(16));

      if (importedPublicKeys.length === 0) {
        alert("暗号化のために公開鍵がインポートされていません。");
        return;
      }
      const rsaEntries = [];
      for (let pub of importedPublicKeys) {
        try {
          const encKeyBuffer = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, pub.cryptoKey, aesKeyRaw);
          rsaEntries.push({ modulus: pub.modulus, encKey: new Uint8Array(encKeyBuffer) });
        } catch (err) {
          console.error("RSA暗号化失敗: ", err);
        }
      }
      if (rsaEntries.length === 0) {
        alert("有効な公開鍵がありません。");
        return;
      }
      const fileBuffer = new Uint8Array(await file.arrayBuffer());
      const encoder = new TextEncoder();
      const fileNameBytes = encoder.encode(file.name);
      const payloadPlain = concatUint8Arrays([writeInt32LE(fileNameBytes.length), fileNameBytes, fileBuffer]);
      const payloadEnc = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-CBC", iv: iv }, aesKey, payloadPlain));
      const parts = [];
      parts.push(writeInt32LE(rsaEntries.length));
      rsaEntries.forEach(entry => {
        const modBytes = encoder.encode(entry.modulus);
        parts.push(writeInt32LE(modBytes.length));
        parts.push(modBytes);
        parts.push(writeInt32LE(entry.encKey.length));
        parts.push(entry.encKey);
      });
      parts.push(iv);
      parts.push(payloadEnc);
      const finalData = concatUint8Arrays(parts);
      const blob = new Blob([finalData], { type: "application/octet-stream" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = file.name + ".enc";
      a.click();
    }

    // ── ファイル復号処理（秘密鍵は IndexedDB から自動選択） ──
    async function decryptFile(file) {
      if (importedPrivateKeys.length === 0) {
        alert("復号のための秘密鍵が存在しません。");
        return;
      }
      const fileBuffer = new Uint8Array(await file.arrayBuffer());
      const view = new DataView(fileBuffer.buffer);
      let offset = 0;
      if (fileBuffer.length < 4) {
        alert("ファイルが不正です。");
        return;
      }
      const entryCount = readInt32LE(view, offset);
      offset += 4;
      const rsaEntries = [];
      const decoder = new TextDecoder();
      for (let i = 0; i < entryCount; i++) {
        const modLen = readInt32LE(view, offset); offset += 4;
        const modBytes = fileBuffer.slice(offset, offset + modLen); offset += modLen;
        const modulus = decoder.decode(modBytes);
        const encKeyLen = readInt32LE(view, offset); offset += 4;
        const encKey = fileBuffer.slice(offset, offset + encKeyLen); offset += encKeyLen;
        rsaEntries.push({ modulus: modulus, encKey: encKey });
      }
      if (offset + 16 > fileBuffer.length) {
        alert("ファイルが不正です。");
        return;
      }
      const iv = fileBuffer.slice(offset, offset + 16); offset += 16;
      const payloadEnc = fileBuffer.slice(offset);
      let aesKeyRaw, found = false;
      for (let entry of rsaEntries) {
        for (let priv of importedPrivateKeys) {
          if (priv.modulus === entry.modulus) {
            try {
              aesKeyRaw = new Uint8Array(await crypto.subtle.decrypt({ name: "RSA-OAEP" }, priv.cryptoKey, entry.encKey));
              found = true;
              break;
            } catch (err) {
              console.error("RSA復号エラー: ", err);
            }
          }
        }
        if (found) break;
      }
      if (!found || !aesKeyRaw) {
        alert("一致する秘密鍵が見つからないか、AES鍵の復号に失敗しました。");
        return;
      }
      const aesKey = await crypto.subtle.importKey("raw", aesKeyRaw, { name: "AES-CBC" }, true, ["decrypt"]);
      let payloadPlainBuffer;
      try {
        payloadPlainBuffer = await crypto.subtle.decrypt({ name: "AES-CBC", iv: iv }, aesKey, payloadEnc);
      } catch (err) {
        alert("AES復号に失敗しました: " + err.message);
        return;
      }
      const payloadPlain = new Uint8Array(payloadPlainBuffer);
      const dv = new DataView(payloadPlain.buffer);
      const fnameLen = dv.getInt32(0, true);
      if (4 + fnameLen > payloadPlain.length) {
        alert("復号結果が不正です。");
        return;
      }
      const fnameBytes = payloadPlain.slice(4, 4 + fnameLen);
      const originalFileName = decoder.decode(fnameBytes);
      const fileContent = payloadPlain.slice(4 + fnameLen);
      const blob = new Blob([fileContent], { type: "application/octet-stream" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = originalFileName;
      a.click();
    }

    // ── ボタン押下時の処理 ──
    // 復号ボタン
    document.getElementById('decryptBtn').addEventListener('click', () => {
      if (filesToProcess.length === 0) {
        alert("復号するファイルがありません。");
        return;
      }
      filesToProcess.forEach(file => { decryptFile(file); });
      filesToProcess.length = 0;
      fileListElem.innerHTML = "";
      fileDropArea.textContent = "ここにファイルをドロップ";
    });

    // 公開鍵エリア内の暗号化ボタン
    document.getElementById('encryptBtn').addEventListener('click', () => {
      if (filesToProcess.length === 0) {
        alert("暗号化するファイルがありません。");
        return;
      }
      filesToProcess.forEach(file => { encryptFile(file); });
      filesToProcess.length = 0;
      fileListElem.innerHTML = "";
      fileDropArea.textContent = "ここにファイルをドロップ";
    });

    // ── 鍵管理機能 ──
    // 鍵生成（RSA-OAEP 4096bit, SHA-1）
    async function generateKeyPair(name) {
      const algorithm = {
        name: "RSA-OAEP",
        modulusLength: 4096,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: "SHA-1" }
      };
      try {
        const keyPair = await crypto.subtle.generateKey(algorithm, true, ["encrypt", "decrypt"]);
        keyStore[name] = keyPair;
        const publicJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
        const privateJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
        await storeKeyPair(name, publicJwk, privateJwk);
        const modulus = base64UrlToBase64(publicJwk.n);
        importedPublicKeys.push({ name: name, modulus: modulus, cryptoKey: keyPair.publicKey });
        importedPrivateKeys.push({ name: name, modulus: modulus, cryptoKey: keyPair.privateKey });
        alert("鍵ペア生成完了: " + name);
        refreshKeyList();
      } catch (e) {
        console.error(e);
        alert("鍵生成エラー: " + e);
      }
    }

    // 鍵一覧テーブルの更新（削除ボタンを追加）
    function refreshKeyList() {
      const tbody = document.getElementById("keyTable").querySelector("tbody");
      tbody.innerHTML = "";
      for (const name in keyStore) {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        tdName.textContent = name;
        const tdOps = document.createElement("td");

        const exportPubBtn = document.createElement("button");
        exportPubBtn.textContent = "公開鍵エクスポート";
        exportPubBtn.onclick = () => exportKey(name, "public");

        const exportPrivBtn = document.createElement("button");
        exportPrivBtn.textContent = "秘密鍵エクスポート";
        exportPrivBtn.onclick = () => exportKey(name, "private");

        const testBtn = document.createElement("button");
        testBtn.textContent = "テスト";
        testBtn.onclick = () => testKeyPair(name);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "削除";
        deleteBtn.onclick = () => deleteKey(name);

        tdOps.appendChild(exportPubBtn);
        tdOps.appendChild(document.createTextNode("　"));
        tdOps.appendChild(exportPrivBtn);
        tdOps.appendChild(document.createTextNode("　"));
        tdOps.appendChild(testBtn);
        tdOps.appendChild(document.createTextNode("　"));
        tdOps.appendChild(deleteBtn);

        tr.appendChild(tdName);
        tr.appendChild(tdOps);
        tbody.appendChild(tr);
      }
    }

    // JWK から XML 形式へ変換
    function convertPublicJwkToXml(jwk) {
      const modulus = base64UrlToBase64(jwk.n);
      const exponent = base64UrlToBase64(jwk.e);
      return `<RSAKeyValue><Modulus>${modulus}</Modulus><Exponent>${exponent}</Exponent></RSAKeyValue>`;
    }
    function convertPrivateJwkToXml(jwk) {
      const modulus = base64UrlToBase64(jwk.n);
      const exponent = base64UrlToBase64(jwk.e);
      const d = base64UrlToBase64(jwk.d);
      const p = base64UrlToBase64(jwk.p);
      const q = base64UrlToBase64(jwk.q);
      const dp = base64UrlToBase64(jwk.dp);
      const dq = base64UrlToBase64(jwk.dq);
      const inverseQ = base64UrlToBase64(jwk.qi);
      return `<RSAKeyValue><Modulus>${modulus}</Modulus><Exponent>${exponent}</Exponent>` +
             `<P>${p}</P><Q>${q}</Q><DP>${dp}</DP><DQ>${dq}</DQ><InverseQ>${inverseQ}</InverseQ>` +
             `<D>${d}</D></RSAKeyValue>`;
    }

    async function exportKey(name, type) {
      const keyPair = keyStore[name];
      let key;
      if (type === "public") {
        if (!keyPair.publicKey) { alert("公開鍵が存在しません"); return; }
        key = keyPair.publicKey;
      } else if (type === "private") {
        if (!keyPair.privateKey) { alert("秘密鍵が存在しません"); return; }
        key = keyPair.privateKey;
      }
      try {
        const jwk = await crypto.subtle.exportKey("jwk", key);
        let xml;
        if (type === "public") {
          xml = convertPublicJwkToXml(jwk);
        } else {
          xml = convertPrivateJwkToXml(jwk);
        }
        const exportArea = document.getElementById("exportArea");
        exportArea.innerHTML = `<h3>${name} の ${type === "public" ? "公開鍵" : "秘密鍵"} エクスポート結果</h3>`;
        const textarea = document.createElement("textarea");
        textarea.rows = 10;
        textarea.value = xml;
        exportArea.appendChild(textarea);
        const blob = new Blob([xml], { type: "application/xml" });
        const url = URL.createObjectURL(blob);
        const downloadLink = document.createElement("a");
        downloadLink.href = url;
        downloadLink.download = name + (type === "public" ? ".pubkey" : ".pvtkey");
        downloadLink.textContent = "Download " + (type === "public" ? "公開鍵" : "秘密鍵");
        exportArea.appendChild(document.createElement("br"));
        exportArea.appendChild(downloadLink);
      } catch (e) {
        console.error(e);
        alert("エクスポートエラー: " + e);
      }
    }

    async function testKeyPair(name) {
      const keyPair = keyStore[name];
      if (!keyPair || !keyPair.publicKey || !keyPair.privateKey) {
        alert("鍵ペアが不完全です");
        return;
      }
      const data = new TextEncoder().encode("TestEncryption");
      try {
        const encrypted = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, keyPair.publicKey, data);
        const decrypted = await crypto.subtle.decrypt({ name: "RSA-OAEP" }, keyPair.privateKey, encrypted);
        const result = new TextDecoder().decode(decrypted);
        alert(result === "TestEncryption" ? "暗号化／復号テスト成功" : "暗号化／復号テスト失敗");
      } catch (e) {
        console.error(e);
        alert("暗号化／復号テストエラー: " + e);
      }
    }

    async function deleteKey(name) {
      if (!confirm("鍵 " + name + " を削除してよろしいですか？")) return;
      // IndexedDB から削除
      try {
        await deleteKeyRecord(name);
      } catch (e) {
        console.error("DB削除エラー", e);
      }
      // 内部管理オブジェクトから削除
      delete keyStore[name];
      // インポート済み配列から削除
      const pubIndex = importedPublicKeys.findIndex(k => k.name === name);
      if (pubIndex >= 0) { importedPublicKeys.splice(pubIndex, 1); }
      const privIndex = importedPrivateKeys.findIndex(k => k.name === name);
      if (privIndex >= 0) { importedPrivateKeys.splice(privIndex, 1); }
      alert("鍵 " + name + " を削除しました");
      refreshKeyList();
    }

    // 鍵生成ボタンのイベント登録
    document.getElementById("generateKeyButton").addEventListener("click", async function() {
      const keyName = document.getElementById("keyNameInput").value.trim();
      const regex = /^[A-Za-z0-9_\-@\.]+$/;
      if (!regex.test(keyName)) {
        alert("鍵名が不正です。英数字、_, -, @, . のみ使用可能です。");
        return;
      }
      if (keyStore[keyName]) {
        alert("同名の鍵が既に存在します");
        return;
      }
      await generateKeyPair(keyName);
    });

    window.addEventListener("load", () => {
      initDB();
    });
  </script>
</body>
</html>
