<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>EasyCrypt</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1, h2, h3 { margin-bottom: 10px; }
    /* ファイルドラッグ領域 */
    #fileDropArea {
      border: 2px dashed #888;
      padding: 20px;
      text-align: center;
      margin-bottom: 10px;
    }
    .key-section { border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; }
    .warning-section {
      border: 2px solid red;
      padding: 10px;
      margin-bottom: 20px;
      background-color: #ffecec;
    }
    button { margin: 5px; }
    ul { list-style: none; padding-left: 0; }
    li { margin-bottom: 5px; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    textarea { width: 100%; }
    section { margin-bottom: 30px; }

    /* スピナーのスタイル */
    #spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border: 1px solid #ccc;
      border-radius: 10px;
      z-index: 1000;
      text-align: center;
      font-size: 1.2em;
    }
  </style>
</head>
<body>
  <h1>EasyCrypt</h1>
  <div>鍵はブラウザ内の IndexedDB に保存されます。ブラウザを閉じても保持され、すべての処理はローカルで実施されます。</div>
  <div>つかいかたは<a href="https://note.com/maclir_cala/n/n1837fd391ede" target="_blank">ブラウザ版：公開鍵暗号を使用した暗号化/復号のコードを実装しました</a>をごらんください。</div>
  
  <!-- スピナー（処理中表示） -->
  <div id="spinner">処理中...</div>

  <!-- ファイル暗号化／復号セクション -->
  <section id="fileSection">
    <h2>暗号化／復号の対象ファイル</h2>
    <div id="fileDropArea">ここにファイルをドロップ</div>
    <!-- ファイル選択ボタンを追加 -->
    <input type="file" id="fileSelect" multiple style="margin-top:10px;">
    <ul id="fileList"></ul>
    <div class="key-section">
      <h2>復号</h2>
      秘密鍵は鍵一覧から自動選択されます
      <div>
        <button id="decryptBtn">復号</button>
      </div>
    </div>
  </section>

  <!-- 公開鍵インポート（暗号化に使用） -->
  <section id="keyImport">
    <div class="key-section">
      <h2>暗号化</h2>
      暗号化で使用する公開鍵のファイルを読み込んでください
      <h3>公開鍵選択 (.pubkey XML)</h3>
      <input type="file" id="pubKeyInput" accept=".pubkey" multiple>
      <button id="encryptBtn">暗号化</button>
      <ul id="pubKeyList"></ul>
    </div>
  </section>

  <!-- 秘密鍵インポート -->
  <section id="privKeyImport">
    <div class="key-section">
      <h2>秘密鍵インポート (.pvtkey XML)</h2>
      <input type="file" id="privKeyInput" accept=".pvtkey" multiple>
      <ul id="privKeyList"></ul>
    </div>
  </section>

  <!-- 鍵管理セクション -->
  <section id="keyManagement">
    <div class="key-section">
      <h2>鍵管理</h2>
      <div>
        <label for="keyNameInput">鍵名 (英数字、_, -, @, . のみ): </label>
        <input type="text" id="keyNameInput" placeholder="例: MyKey01">
        <button id="generateKeyButton">鍵生成</button>
      </div>
      <div>
        <h3>鍵一覧</h3>
        <table id="keyTable">
          <thead>
            <tr>
              <th>鍵名</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="exportArea"></div>
    </div>
  </section>

  <!-- 取り扱い注意！セクション：IndexedDB初期化ボタン -->
  <section id="resetSection" class="warning-section">
    <h2>取り扱い注意！</h2>
    <p>
      以下の操作は、<strong>すべての鍵情報を削除</strong>します。<br>
      この操作は元に戻せませんので、十分に注意してください。
    </p>
    <button id="resetDBBtn" style="background-color: red; color: white;">鍵一覧初期化</button>
  </section>

  <script>
    // ── スピナーの表示・非表示関数 ──
    function showSpinner() {
      document.getElementById('spinner').style.display = 'block';
    }
    function hideSpinner() {
      document.getElementById('spinner').style.display = 'none';
    }

    // ── 定数の定義 ──
    const RSA_ALGORITHM = "RSA-OAEP";
    const RSA_HASH = "SHA-256";
    const AES_ALGORITHM = "AES-GCM";
    const AES_KEY_LENGTH = 256;
    const AES_IV_LENGTH = 12;

    // ── グローバル変数 ──
    let db;
    const keyStore = {}; // 鍵管理用（鍵管理一覧に表示される鍵ペア）
    const importedPublicKeys = [];   // 暗号化用公開鍵（鍵管理一覧には登録しない）
    const importedPrivateKeys = [];  // { name, modulus, cryptoKey }
    const filesToProcess = [];       // ドラッグ＆ドロップまたはファイル選択されたファイル

    // ── exportArea クリア用の補助関数 ──
    function clearExportArea() {
      document.getElementById("exportArea").innerHTML = "";
    }

    // ── IndexedDB 初期化と操作 ──
    function initDB() {
      const request = indexedDB.open("EasyCryptDB", 1);
      request.onupgradeneeded = function(e) {
        db = e.target.result;
        if (!db.objectStoreNames.contains("keys")) {
          db.createObjectStore("keys", { keyPath: "name" });
        }
      };
      request.onsuccess = function(e) {
        db = e.target.result;
        loadKeysFromDB();
      };
      request.onerror = function(e) {
        console.error("IndexedDB error", e);
      };
    }

    function storeKeyRecord(record) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction("keys", "readwrite");
        const store = transaction.objectStore("keys");
        const req = store.put(record);
        req.onsuccess = () => resolve();
        req.onerror = (e) => reject(e);
      });
    }

    function deleteKeyRecord(name) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction("keys", "readwrite");
        const store = transaction.objectStore("keys");
        const req = store.delete(name);
        req.onsuccess = () => resolve();
        req.onerror = (e) => reject(e);
      });
    }

    function getKeyRecord(name) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction("keys", "readonly");
        const store = transaction.objectStore("keys");
        const req = store.get(name);
        req.onsuccess = () => resolve(req.result);
        req.onerror = (e) => reject(e);
      });
    }

    async function storeKeyPair(name, publicJwk, privateJwk) {
      let record = await getKeyRecord(name);
      if (!record) {
        record = { name: name, publicKeyJwk: publicJwk, privateKeyJwk: privateJwk };
      } else {
        record.publicKeyJwk = publicJwk;
        record.privateKeyJwk = privateJwk;
      }
      await storeKeyRecord(record);
    }

    async function storePartialKey(name, jwk, type) {
      let record = await getKeyRecord(name);
      if (!record) {
        record = { name: name, publicKeyJwk: null, privateKeyJwk: null };
      }
      if (type === "public") {
        record.publicKeyJwk = jwk;
      } else if (type === "private") {
        record.privateKeyJwk = jwk;
      }
      await storeKeyRecord(record);
    }

    function loadKeysFromDB() {
      const transaction = db.transaction("keys", "readonly");
      const store = transaction.objectStore("keys");
      const req = store.getAll();
      req.onsuccess = async function() {
        const records = req.result;
        for (const record of records) {
          if (record.publicKeyJwk) {
            const pubKey = await crypto.subtle.importKey(
              "jwk", record.publicKeyJwk,
              { name: RSA_ALGORITHM, hash: RSA_HASH },
              true, ["encrypt"]
            );
            const modulus = base64UrlToBase64(record.publicKeyJwk.n);
            importedPublicKeys.push({ name: record.name, modulus: modulus, cryptoKey: pubKey });
            if (!keyStore[record.name]) { keyStore[record.name] = { publicKey: null, privateKey: null }; }
            keyStore[record.name].publicKey = pubKey;
          }
          if (record.privateKeyJwk) {
            const privKey = await crypto.subtle.importKey(
              "jwk", record.privateKeyJwk,
              { name: RSA_ALGORITHM, hash: RSA_HASH },
              true, ["decrypt"]
            );
            const modulus = record.publicKeyJwk ? base64UrlToBase64(record.publicKeyJwk.n) : "";
            importedPrivateKeys.push({ name: record.name, modulus: modulus, cryptoKey: privKey });
            if (!keyStore[record.name]) { keyStore[record.name] = { publicKey: null, privateKey: null }; }
            keyStore[record.name].privateKey = privKey;
          }
        }
        refreshKeyList();
      }
    }

    // ── ユーティリティ関数 ──
    function concatUint8Arrays(arrays) {
      let total = arrays.reduce((sum, arr) => sum + arr.length, 0);
      let result = new Uint8Array(total);
      let offset = 0;
      arrays.forEach(arr => { result.set(arr, offset); offset += arr.length; });
      return result;
    }
    function writeInt32LE(val) {
      const buf = new ArrayBuffer(4);
      new DataView(buf).setInt32(0, val, true);
      return new Uint8Array(buf);
    }
    function readInt32LE(view, offset) {
      return view.getInt32(offset, true);
    }
    // 標準 base64 → base64url（パディング除去）
    function base64ToBase64Url(b64) {
      return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }
    // base64url → 標準 base64（パディング追加）
    function base64UrlToBase64(url) {
      let b64 = url.replace(/-/g, '+').replace(/_/g, '/');
      while (b64.length % 4 !== 0) { b64 += '='; }
      return b64;
    }
    // XML から指定タグの内容取得
    function getXmlTagContent(xmlDoc, tagName) {
      const el = xmlDoc.getElementsByTagName(tagName)[0];
      return el ? el.textContent.trim() : null;
    }

    // ── XML 形式の公開鍵インポート ──
    async function importPublicKeyFromXml(xmlString, fileName) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "application/xml");
      const modulus = getXmlTagContent(xmlDoc, "Modulus");
      const exponent = getXmlTagContent(xmlDoc, "Exponent");
      if (!modulus || !exponent) {
        throw new Error("公開鍵XMLに Modulus または Exponent が見つかりません");
      }
      const n = base64ToBase64Url(modulus);
      const e = base64ToBase64Url(exponent);
      const jwk = { kty: "RSA", n: n, e: e, ext: true };
      const cryptoKey = await crypto.subtle.importKey(
        "jwk", jwk,
        { name: RSA_ALGORITHM, hash: RSA_HASH },
        true, ["encrypt"]
      );
      return { name: fileName, modulus: modulus, cryptoKey: cryptoKey };
    }

    // ── XML 形式の秘密鍵インポート ──
    async function importPrivateKeyFromXml(xmlString, fileName) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, "application/xml");
      const modulus = getXmlTagContent(xmlDoc, "Modulus");
      const exponent = getXmlTagContent(xmlDoc, "Exponent");
      const d = getXmlTagContent(xmlDoc, "D");
      const p = getXmlTagContent(xmlDoc, "P");
      const q = getXmlTagContent(xmlDoc, "Q");
      const dp = getXmlTagContent(xmlDoc, "DP");
      const dq = getXmlTagContent(xmlDoc, "DQ");
      const inverseQ = getXmlTagContent(xmlDoc, "InverseQ");
      if (!modulus || !exponent || !d || !p || !q || !dp || !dq || !inverseQ) {
        throw new Error("秘密鍵XMLに必要な要素が見つかりません");
      }
      const jwkPrivate = {
        kty: "RSA",
        n: base64ToBase64Url(modulus),
        e: base64ToBase64Url(exponent),
        d: base64ToBase64Url(d),
        p: base64ToBase64Url(p),
        q: base64ToBase64Url(q),
        dp: base64ToBase64Url(dp),
        dq: base64ToBase64Url(dq),
        qi: base64ToBase64Url(inverseQ),
        ext: true
      };
      const privateCryptoKey = await crypto.subtle.importKey(
        "jwk", jwkPrivate,
        { name: RSA_ALGORITHM, hash: RSA_HASH },
        true, ["decrypt"]
      );
      const jwkPublic = {
        kty: "RSA",
        n: base64ToBase64Url(modulus),
        e: base64ToBase64Url(exponent),
        ext: true
      };
      const publicCryptoKey = await crypto.subtle.importKey(
        "jwk", jwkPublic,
        { name: RSA_ALGORITHM, hash: RSA_HASH },
        true, ["encrypt"]
      );
      return {
        name: fileName,
        modulus: modulus,
        publicKey: publicCryptoKey,
        privateKey: privateCryptoKey
      };
    }

    // ── ファイルドラッグ＆ドロップ処理 ──
    const fileDropArea = document.getElementById('fileDropArea');
    const fileListElem = document.getElementById('fileList');
    fileDropArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileDropArea.style.borderColor = "#000";
    });
    fileDropArea.addEventListener('dragleave', (e) => {
      e.preventDefault();
      fileDropArea.style.borderColor = "#888";
    });
    fileDropArea.addEventListener('drop', (e) => {
      e.preventDefault();
      fileDropArea.style.borderColor = "#888";
      const files = e.dataTransfer.files;
      for (let file of files) {
        filesToProcess.push(file);
        const li = document.createElement('li');
        li.textContent = file.name;
        fileListElem.appendChild(li);
      }
    });

    // ── ファイル選択ボタン処理 ──
    document.getElementById('fileSelect').addEventListener('change', (e) => {
      const files = e.target.files;
      for (let file of files) {
        filesToProcess.push(file);
        const li = document.createElement('li');
        li.textContent = file.name;
        fileListElem.appendChild(li);
      }
    });

    // ── 公開鍵ファイル入力（インポート＆暗号化用登録） ──
    const pubKeyListElem = document.getElementById('pubKeyList');
    document.getElementById('pubKeyInput').addEventListener('change', async (e) => {
      const files = e.target.files;
      for (let file of files) {
        const text = await file.text();
        try {
          const pubKey = await importPublicKeyFromXml(text, file.name);
          // 暗号化用公開鍵としてのみ利用し、鍵管理（keyStore/IndexedDB）には登録しない
          importedPublicKeys.push(pubKey);
          const li = document.createElement('li');
          li.textContent = pubKey.name;
          pubKeyListElem.appendChild(li);
        } catch(err) {
          alert("公開鍵 " + file.name + " のインポートエラー: " + err.message);
        }
      }
      e.target.value = "";
    });

    // ── 秘密鍵ファイル入力（インポート＆DB保存、公開鍵自動生成） ──
    const privKeyListElem = document.getElementById('privKeyList');
    document.getElementById('privKeyInput').addEventListener('change', async (e) => {
      const files = e.target.files;
      for (let file of files) {
        const text = await file.text();
        try {
          let keyName = file.name;
          if (keyName.toLowerCase().endsWith(".pvtkey")) {
            keyName = keyName.slice(0, -7);
          }
          const keyPair = await importPrivateKeyFromXml(text, keyName);
          // 鍵ペアは１エントリーとして管理する
          if (!keyStore[keyPair.name]) {
            keyStore[keyPair.name] = { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey };
            importedPublicKeys.push({ name: keyPair.name, modulus: keyPair.modulus, cryptoKey: keyPair.publicKey });
            importedPrivateKeys.push({ name: keyPair.name, modulus: keyPair.modulus, cryptoKey: keyPair.privateKey });
            const li = document.createElement('li');
            li.textContent = keyPair.name;
            privKeyListElem.appendChild(li);
          } else {
            keyStore[keyPair.name] = { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey };
            const pubIndex = importedPublicKeys.findIndex(k => k.name === keyPair.name);
            if (pubIndex >= 0) {
              importedPublicKeys[pubIndex] = { name: keyPair.name, modulus: keyPair.modulus, cryptoKey: keyPair.publicKey };
            } else {
              importedPublicKeys.push({ name: keyPair.name, modulus: keyPair.modulus, cryptoKey: keyPair.publicKey });
            }
            const privIndex = importedPrivateKeys.findIndex(k => k.name === keyPair.name);
            if (privIndex >= 0) {
              importedPrivateKeys[privIndex] = { name: keyPair.name, modulus: keyPair.modulus, cryptoKey: keyPair.privateKey };
            } else {
              importedPrivateKeys.push({ name: keyPair.name, modulus: keyPair.modulus, cryptoKey: keyPair.privateKey });
            }
          }
          const publicJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
          const privateJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
          await storeKeyPair(keyPair.name, publicJwk, privateJwk);
          removeFileFromFileList(file.name);
          refreshKeyList();
          // 秘密鍵インポート後はエクスポート表示領域をクリア
          clearExportArea();
        } catch(err) {
          alert("秘密鍵 " + file.name + " のインポートエラー: " + err.message);
        }
      }
      e.target.value = "";
    });

    // ── ファイル一覧から特定のファイルを削除する関数 ──
    function removeFileFromFileList(fileName) {
      const items = fileListElem.getElementsByTagName("li");
      for (let i = items.length - 1; i >= 0; i--) {
        if (items[i].textContent === fileName) {
          items[i].remove();
        }
      }
      for (let i = filesToProcess.length - 1; i >= 0; i--) {
        if (filesToProcess[i].name === fileName) {
          filesToProcess.splice(i, 1);
        }
      }
    }

    // ── ファイル暗号化処理 ──
    async function encryptFile(file) {
      const aesKey = await crypto.subtle.generateKey(
        { name: AES_ALGORITHM, length: AES_KEY_LENGTH },
        true, ["encrypt", "decrypt"]
      );
      const aesKeyRaw = new Uint8Array(await crypto.subtle.exportKey("raw", aesKey));
      const iv = window.crypto.getRandomValues(new Uint8Array(AES_IV_LENGTH));

      if (importedPublicKeys.length === 0) {
        alert("暗号化のために公開鍵がインポートされていません。");
        return;
      }
      const rsaEntries = [];
      for (let pub of importedPublicKeys) {
        try {
          const encKeyBuffer = await crypto.subtle.encrypt({ name: RSA_ALGORITHM }, pub.cryptoKey, aesKeyRaw);
          rsaEntries.push({ modulus: pub.modulus, encKey: new Uint8Array(encKeyBuffer) });
        } catch (err) {
          console.error("RSA暗号化失敗: ", err);
        }
      }
      if (rsaEntries.length === 0) {
        alert("有効な公開鍵がありません。");
        return;
      }
      const fileBuffer = new Uint8Array(await file.arrayBuffer());
      const encoder = new TextEncoder();
      const fileNameBytes = encoder.encode(file.name);
      const payloadPlain = concatUint8Arrays([writeInt32LE(fileNameBytes.length), fileNameBytes, fileBuffer]);
      const payloadEnc = new Uint8Array(await crypto.subtle.encrypt({ name: AES_ALGORITHM, iv: iv }, aesKey, payloadPlain));
      const parts = [];
      parts.push(writeInt32LE(rsaEntries.length));
      rsaEntries.forEach(entry => {
        const modBytes = encoder.encode(entry.modulus);
        parts.push(writeInt32LE(modBytes.length));
        parts.push(modBytes);
        parts.push(writeInt32LE(entry.encKey.length));
        parts.push(entry.encKey);
      });
      parts.push(iv);
      parts.push(payloadEnc);
      const finalData = concatUint8Arrays(parts);
      const blob = new Blob([finalData], { type: "application/octet-stream" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = file.name + ".easycrypted";
      a.click();
    }

    // ── ファイル復号処理 ──
    async function decryptFile(file) {
      try {
        if (importedPrivateKeys.length === 0) {
          throw new Error("復号のための秘密鍵が存在しません。");
        }
        const fileBuffer = new Uint8Array(await file.arrayBuffer());
        const view = new DataView(fileBuffer.buffer);
        let offset = 0;
        if (fileBuffer.length < 4) {
          throw new Error("ファイルが不正です。");
        }
        const entryCount = readInt32LE(view, offset);
        offset += 4;
        const rsaEntries = [];
        const decoder = new TextDecoder();
        for (let i = 0; i < entryCount; i++) {
          if (offset + 4 > fileBuffer.length) {
            throw new Error("ファイルが不正です。");
          }
          const modLen = readInt32LE(view, offset);
          offset += 4;
          if (offset + modLen > fileBuffer.length) {
            throw new Error("ファイルが不正です。");
          }
          const modBytes = fileBuffer.slice(offset, offset + modLen); offset += modLen;
          const modulus = decoder.decode(modBytes);
          if (offset + 4 > fileBuffer.length) {
            throw new Error("ファイルが不正です。");
          }
          const encKeyLen = readInt32LE(view, offset); offset += 4;
          if (offset + encKeyLen > fileBuffer.length) {
            throw new Error("ファイルが不正です。");
          }
          const encKey = fileBuffer.slice(offset, offset + encKeyLen); offset += encKeyLen;
          rsaEntries.push({ modulus: modulus, encKey: encKey });
        }
        if (offset + AES_IV_LENGTH > fileBuffer.length) {
          throw new Error("ファイルが不正です。");
        }
        const iv = fileBuffer.slice(offset, offset + AES_IV_LENGTH); offset += AES_IV_LENGTH;
        const payloadEnc = fileBuffer.slice(offset);
        let aesKeyRaw, found = false;
        for (let entry of rsaEntries) {
          for (let priv of importedPrivateKeys) {
            if (priv.modulus === entry.modulus) {
              try {
                aesKeyRaw = new Uint8Array(await crypto.subtle.decrypt({ name: RSA_ALGORITHM }, priv.cryptoKey, entry.encKey));
                found = true;
                break;
              } catch (err) {
                // 各鍵での復号エラーは無視して次を試す
              }
            }
          }
          if (found) break;
        }
        if (!found || !aesKeyRaw) {
          throw new Error("一致する秘密鍵が見つからないか、AES鍵の復号に失敗しました。");
        }
        const aesKey = await crypto.subtle.importKey("raw", aesKeyRaw, { name: AES_ALGORITHM }, true, ["decrypt"]);
        let payloadPlainBuffer;
        try {
          payloadPlainBuffer = await crypto.subtle.decrypt({ name: AES_ALGORITHM, iv: iv }, aesKey, payloadEnc);
        } catch (err) {
          throw new Error("AES復号に失敗しました: " + err.message);
        }
        const payloadPlain = new Uint8Array(payloadPlainBuffer);
        const dv = new DataView(payloadPlain.buffer);
        if (payloadPlain.length < 4) {
          throw new Error("復号結果が不正です。");
        }
        const fnameLen = dv.getInt32(0, true);
        if (4 + fnameLen > payloadPlain.length) {
          throw new Error("復号結果が不正です。");
        }
        const fnameBytes = payloadPlain.slice(4, 4 + fnameLen);
        const originalFileName = decoder.decode(fnameBytes);
        const fileContent = payloadPlain.slice(4 + fnameLen);
        const blob = new Blob([fileContent], { type: "application/octet-stream" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = originalFileName;
        a.click();
      } catch (err) {
        alert("復号エラー: " + err.message);
      }
    }

    // ── ボタン押下時の処理（スピナー表示付き） ──
    document.getElementById('decryptBtn').addEventListener('click', async () => {
      if (filesToProcess.length === 0) {
        alert("復号するファイルがありません。");
        return;
      }
      showSpinner();
      for (let file of filesToProcess) {
        await decryptFile(file);
      }
      filesToProcess.length = 0;
      fileListElem.innerHTML = "";
      fileDropArea.textContent = "ここにファイルをドロップ";
      pubKeyListElem.innerHTML = "";
      hideSpinner();
    });

    document.getElementById('encryptBtn').addEventListener('click', async () => {
      if (filesToProcess.length === 0) {
        alert("暗号化するファイルがありません。");
        return;
      }
      showSpinner();
      for (let file of filesToProcess) {
        await encryptFile(file);
      }
      filesToProcess.length = 0;
      fileListElem.innerHTML = "";
      fileDropArea.textContent = "ここにファイルをドロップ";
      pubKeyListElem.innerHTML = "";
      hideSpinner();
    });

    // ── 鍵管理機能 ──
    async function generateKeyPair(name) {
      const algorithm = {
        name: RSA_ALGORITHM,
        modulusLength: 4096,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: RSA_HASH }
      };
      try {
        const keyPair = await crypto.subtle.generateKey(algorithm, true, ["encrypt", "decrypt"]);
        keyStore[name] = keyPair;
        const publicJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
        const privateJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
        await storeKeyPair(name, publicJwk, privateJwk);
        const modulus = base64UrlToBase64(publicJwk.n);
        importedPublicKeys.push({ name: name, modulus: modulus, cryptoKey: keyPair.publicKey });
        importedPrivateKeys.push({ name: name, modulus: modulus, cryptoKey: keyPair.privateKey });
        alert("鍵ペア生成完了: " + name);
        refreshKeyList();
      } catch (e) {
        console.error(e);
        alert("鍵生成エラー: " + e);
      }
    }

    function refreshKeyList() {
      const tbody = document.getElementById("keyTable").querySelector("tbody");
      tbody.innerHTML = "";
      for (const name in keyStore) {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        tdName.textContent = name;
        const tdOps = document.createElement("td");

        const exportPubBtn = document.createElement("button");
        exportPubBtn.textContent = "公開鍵エクスポート";
        exportPubBtn.onclick = () => exportKey(name, "public");

        const exportPrivBtn = document.createElement("button");
        exportPrivBtn.textContent = "秘密鍵エクスポート";
        exportPrivBtn.onclick = () => exportKey(name, "private");

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "削除";
        deleteBtn.onclick = () => deleteKey(name);

        tdOps.appendChild(exportPubBtn);
        tdOps.appendChild(document.createTextNode("　"));
        tdOps.appendChild(exportPrivBtn);
        tdOps.appendChild(document.createTextNode("　"));
        tdOps.appendChild(deleteBtn);

        tr.appendChild(tdName);
        tr.appendChild(tdOps);
        tbody.appendChild(tr);
      }
    }

    function convertPublicJwkToXml(jwk) {
      const modulus = base64UrlToBase64(jwk.n);
      const exponent = base64UrlToBase64(jwk.e);
      return `<RSAKeyValue><Modulus>${modulus}</Modulus><Exponent>${exponent}</Exponent></RSAKeyValue>`;
    }
    function convertPrivateJwkToXml(jwk) {
      const modulus = base64UrlToBase64(jwk.n);
      const exponent = base64UrlToBase64(jwk.e);
      const d = base64UrlToBase64(jwk.d);
      const p = base64UrlToBase64(jwk.p);
      const q = base64UrlToBase64(jwk.q);
      const dp = base64UrlToBase64(jwk.dp);
      const dq = base64UrlToBase64(jwk.dq);
      const inverseQ = base64UrlToBase64(jwk.qi);
      return `<RSAKeyValue><Modulus>${modulus}</Modulus><Exponent>${exponent}</Exponent>` +
             `<P>${p}</P><Q>${q}</Q><DP>${dp}</DP><DQ>${dq}</DQ><InverseQ>${inverseQ}</InverseQ>` +
             `<D>${d}</D></RSAKeyValue>`;
    }

    async function exportKey(name, type) {
      const keyPair = keyStore[name];
      let key;
      if (type === "public") {
        if (!keyPair.publicKey) { alert("公開鍵が存在しません"); return; }
        key = keyPair.publicKey;
      } else if (type === "private") {
        if (!keyPair.privateKey) { alert("秘密鍵が存在しません"); return; }
        key = keyPair.privateKey;
      }
      try {
        const jwk = await crypto.subtle.exportKey("jwk", key);
        let xml;
        if (type === "public") {
          xml = convertPublicJwkToXml(jwk);
        } else {
          xml = convertPrivateJwkToXml(jwk);
        }
        const exportArea = document.getElementById("exportArea");
        exportArea.innerHTML = `<h3>${name} の ${type === "public" ? "公開鍵" : "秘密鍵"} エクスポート結果</h3>`;
        const textarea = document.createElement("textarea");
        textarea.rows = 10;
        textarea.value = xml;
        exportArea.appendChild(textarea);
        const blob = new Blob([xml], { type: "application/xml" });
        const url = URL.createObjectURL(blob);
        const downloadLink = document.createElement("a");
        downloadLink.href = url;
        downloadLink.download = name + (type === "public" ? ".pubkey" : ".pvtkey");
        downloadLink.textContent = "Download " + (type === "public" ? "公開鍵" : "秘密鍵");
        exportArea.appendChild(document.createElement("br"));
        exportArea.appendChild(downloadLink);
      } catch (e) {
        console.error(e);
        alert("エクスポートエラー: " + e);
      }
    }

    async function deleteKey(name) {
      if (!confirm("鍵 " + name + " を削除してよろしいですか？")) return;
      try {
        await deleteKeyRecord(name);
      } catch (e) {
        console.error("DB削除エラー", e);
      }
      delete keyStore[name];
      const pubIndex = importedPublicKeys.findIndex(k => k.name === name);
      if (pubIndex >= 0) { importedPublicKeys.splice(pubIndex, 1); }
      const privIndex = importedPrivateKeys.findIndex(k => k.name === name);
      if (privIndex >= 0) { importedPrivateKeys.splice(privIndex, 1); }
      alert("鍵 " + name + " を削除しました");
      // 鍵削除後はエクスポート表示領域もクリア
      clearExportArea();
      refreshKeyList();
    }

    document.getElementById("generateKeyButton").addEventListener("click", async function() {
      const keyName = document.getElementById("keyNameInput").value.trim();
      const regex = /^[A-Za-z0-9_\-@\.]+$/;
      if (!regex.test(keyName)) {
        alert("鍵名が不正です。英数字、_, -, @, . のみ使用可能です。");
        return;
      }
      if (keyStore[keyName]) {
        alert("同名の鍵が既に存在します");
        return;
      }
      await generateKeyPair(keyName);
    });

    // ── IndexedDB 初期化（リセット）処理 ──
    function resetDatabase() {
      if (!confirm("本当に全ての鍵一覧を削除しますか？ この操作は元に戻せません。")) return;
      if (db) {
        db.close();
      }
      const req = indexedDB.deleteDatabase("EasyCryptDB");
      req.onsuccess = function() {
        alert("鍵一覧が初期化されました。");
        // 鍵情報クリアと共にエクスポート表示領域も消去
        for (let key in keyStore) { delete keyStore[key]; }
        importedPublicKeys.length = 0;
        importedPrivateKeys.length = 0;
        clearExportArea();
        db = null;
        refreshKeyList();
        initDB();
      };
      req.onerror = function(e) {
        alert("鍵一覧の初期化中にエラーが発生しました。");
      };
      req.onblocked = function(e) {
        alert("他のタブで開いている可能性があります。");
      };
    }

    document.getElementById('resetDBBtn').addEventListener('click', resetDatabase);

    window.addEventListener("load", () => {
      initDB();
    });
  </script>
</body>
</html>
